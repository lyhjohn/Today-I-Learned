서버에서는 클라이언트마다의 세션을 갖고있어.
서버는 클라이언트의 세션을 보고 접근 가능 유무를 판단해.
그런데 서버가 여러대기 때문에 로드밸런싱을 통해 서버를 분산시켜.
따라서 클라이언트의 세션이 여러개의 서버중 하나에 있기 때문에 서버 여러 개를 탐색하면서 세션을 찾는건 비효율적이야.
그래서 보통 여러개의 서버가 하나의 DB를 공유해.
그렇지만 이경우는 하드디스크에서 세션을 찾아오기 때문에 매우 느려.
물론 두번째부터는 RAM이나 가상메모리에서 찾아오기 때문에 빠르지만 아무튼.

이러한 문제를 JWT가 해결해줘

그리고 JWT는 보안 관련해서도 도움을 줘.
만약 데이터를 전송하는데 중간에서 데이터를 가로채 위조하여 보낸다면,
보안 3대 요소 CIA(기밀성, 무결성, 가용성)가 모두 깨지게돼 (무결성 - 데이터 위조)

가용성을 유지하려면 데이터를 보낼 때 데이터를 지켜줄것들을 배치해서 보내야 돼.
무결성을 유지하려면 데이터를 뺏어가지 못하게 해야돼
기밀성을 유지하려면 데이터를 암호화해서 보내야돼.

A와 B가 있고 둘 모두 공개키과 개인키를 들고있어.
A -> B로 데이터를 보낼때 B의 공개키를 함께 담아 보내.
이 데이터는 B의 개인키를 갖고있어야 볼수있어
만약 중간에 해커가 데이터를 가로채도 B의 개인키를 갖고있지 않아서 데이터를 볼 수 없어.

여기까진 데이터 전달하면서 보안은 깨지지 않았어.

이번에는 B가 A한테 데이터를 보내.
마찬가지로 A의 공개키를 담아서 보냈기 때문에 열기 위해서는 A의 개인키를 소지해야해.
이게 데이터를 공개키로 잠궈서 보내는 경우야.
데이터를 암호화할 때 이 방식을 채택해.


이번에는 A가 B에게 정보를 보낼 때 A의 개인키로 데이터를 잠가서 보내는 경우야.
중간에 해커가 데이터를 가로채서 A의 공개키로 열어볼 수 있어.
하지만 이 데이터는 A가 보냈다는게 중요하지 중간에 해커가 확인하고 말고는 크게 중요하지 않은 정보야.
B가 데이터를 받아 A의 공개키로 데이터를 확인하고, 데이터가 A의 개인키로 암호화 되어있었기 때문에
A가 보낸 데이터가 맞다고 확신할 수 있어.
이렇게 데이터를 개인키로 잠구는 방식은 전자문서에 서명할 때 사용해.

즉, A->B 데이터 전송에서 A개인키로 잠금 - B측에서 A공개키로 열어볼수있음 -> 전자서명에 사용
A->B 데이터 전송 시 B공개키로 잠금 - B측에서  B개인키로 열어볼수 있음 - 데이터 암호화

이게 RSA야


이번에는 A가 B에게 비밀번호를 보냈다고 하자.
이 경우에는 데이터를 암호화해야 하기 때문에 B공개키로 잠궈야겠지.
중간에 해커가 가로채도 데이터를 열어볼 수는 없어.
하지만 없앤 후에 새로운 데이터를 B에게 보낼 수는 있지.
그렇기에 A개인키로 비밀번호를 한번 더 잠궈야해.

B는 비밀번호를 받아서 A의 공개키로 우선 열어봐.
A공개키로 열리면? 바꿔치기 당하지 않은 A가 보낸 안전한 데이터임이 인증되는거지.. (가용성, 무결성 유지)
그런 다음 B개인키로 한번 더 열어서 암호화까지 푸는거야. (기밀성 유지)
이렇게 RSA 방식으로 보안의 3대 요소 CIA를 모두 유지할 수 있는거지.






